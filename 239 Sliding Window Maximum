class Solution {
private:
    class MyQueue {
    public:
        deque<int> dq;
        //so in self-defined functions, it pretty much implements the functions in single steps; and in the main function, implement the loop 
        //which calls the self-defined functions in every step based on the data structures etc.
        void popElement(int value) {
            if(!dq.empty() && value == dq.front()) {
                dq.pop_front();
            }
        }
        void pushElement(int value) {
            while(!dq.empty() && value > dq.front()) {
                dq.pop_front();
            }
            dq.push_back(value);
        }
        int frontElement() {
            return dq.front();
        }
    };
public:  //this public is mandatory, otherwise it gets a compile error
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue mq;
        vector<int> res;
        //go through first k window to build mq and res
        for(int i = 0; i < k; i++) {
            mq.pushElement(nums[i]);    //push in this way, it will get the biggest element in the very front of the queue
        }
        res.push_back(mq.frontElement());
        //start moving k window
        for(int i = k; i < nums.size(); i++) {
            mq.popElement(nums[i-k]);    //first element in every window 
            mq.pushElement(nums[i]);    //the element after the window
            res.push_back(mq.frontElement());
        }
        return res;
    }
};

//如果要pop的值在队列的出口处 说明这个值是当前滑动窗口的最大值
//这道题就是自定义了一个单调队列 每滑动一次窗口 就pop出口处元素 push入口处元素 并且get max value of these 3 values which is the 1st value in the current window

