/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        //ListNode* res = new ListNode;
        ListNode* res = new ListNode(0);    
        //make head and res have a value so return res->next, also save the process of assigning a value to head/res
        ListNode* head = res;   //keep head moving and return res
        /*
        if(list1->val < list2->val) {
            head = list1;
            list1 = list1->next;
        }
        else {
            head = list2;
            list2 = list2->next;
        }
        */
        while(list1 && list2) {
            if(list1->val < list2->val) {
                //list1 = list1->next;
                //head = list1;
                head->next = list1;
                list1 = list1->next;
            }
            else {
                //list2 = list2->next;
                //head = list2;
                head->next = list2;
                list2 = list2->next;
            }
            head = head->next;
        }
        /* this part can be replaced with the next part
        if(list1 != NULL) {
            head->next = list1;
        }
        if(list2 != NULL) {
            head->next = list2;
        }
        */
        head->next = list1?list1:list2;
        return res->next;
    }
};


//To deal with linked list problems, generally assign res to head or vice versa, then keep moving one of them in the process for building the list, then return the other one, because they point to the same first node, so they are exactly the same lists.
