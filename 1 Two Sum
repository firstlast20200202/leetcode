//the process of building the map is: basically the keys of map are the indexes of the vector nums, then you add the value of each pair
//building the map can't be the first section of every loop, because when the test case is [3, 3], in the first loop you get [0, 3]
//in the second loop you get {[1, 3], [1, 3]}, which overrides the first pair before testing wnether the element is in the map already (by executing 'if')
//map[nums[i]] = i;
//aka for the case that has two same values, you need two different indexes to output, but if you build the map before first loop, you'll get this value's index as res[0]
//and res[1] both, but actually you should need another index as res[1].

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res(2);
        unordered_map<int, int> map;
        //we cant do it like this as in set and vector: for(int num : nums), because it's only for values, wnereas in maps we need keys and values both
        //also that's why we use map rather than set in this problem: map stores key and value, set only stores value
        for(int i = 0; i < nums.size(); i++) {    
            int tmp = target - nums[i];
            if(map.find(tmp) != map.end()) {
                res[0] = i;
                res[1] = map[tmp];
                break;    //dont execute the current and following loops 
            }
            else {
                who will be the key of the map? the one we are looking for, in this case it's the vector's values rather than the indexes, so the indexes are the map values
                map.insert({nums[i], i});
        }
        return res;
    }
};



//method 2
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
       vector<int> res;
       int sum = 0;
       int sub_start = 0;
       for(int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            res.push_back(i);
            if(sum > target) {
                res.erase(res.begin()+sub_start);
                sub_start++;
            }
            if(sum == target) {
                return res;
            }
       }
       return res;
    }
};



//another solution...
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]); 
            if(iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i)); 
        }
        return {};
    }
};
