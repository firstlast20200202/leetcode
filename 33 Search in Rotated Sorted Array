class Solution {
public:
    int search(vector<int>& nums, int target) {
        return help(nums, target, 0, nums.size()-1);
    }
    int help(vector<int>& nums, int target, int l, int r) {
        if(l>r) return -1;
        int mid = (l+r)/2;
        if(nums[mid] == target) return mid;
        if(nums[mid] > nums[r]) {   //rotate point is at the right side
            if(nums[l] <= target && target < nums[mid]) return help(nums, target, l, mid-1);
            else return help(nums, target, mid+1, r);  
        } 
        else {
            if(nums[mid] < target && target <= nums[r]) return help(nums, target, mid+1, r);
            else return help(nums, target, l, mid-1);
        }
    }
};


//the correct answer is as above, after I looked at it, I optimised it by combing some scenarios as below:
class Solution {
public:
    int search(vector<int>& nums, int target) {
        return help(nums, target, 0, nums.size()-1);
    }
    int help(vector<int>& nums, int target, int l, int r) {
        if(l>r) return -1;
        int mid = (l+r)/2;
        if(nums[mid] == target) return mid;
        //if(nums[mid] > nums[r]) {   //rotate point is at the right side
            if(nums[l] <= target && target < nums[mid]) return help(nums, target, l, mid-1);
            else return help(nums, target, mid+1, r);  
        //} 
        //else {
        //    if(nums[mid] < target && target <= nums[r]) return help(nums, target, mid+1, r);
        //    else return help(nums, target, l, mid-1);
        //}
    }
};
//it's accepted in leetcode, but submission failed, i thought it doesnt matter where the rotate point is, until failed in this case [5, 1, 3]
//the process of this test case with the correct solution is as below:
//help(nums, 5, 0, 2)
//mid = 1
//help(nums, 5, 0, 0)
//mid = 0
//return nums[0]

//the process of this test case with the optimised wrong solution is as below:
//help(nums, 5, 2, 2)
//mid = 2
//help(nums, 5, 3, 2)
//L>r return -1
//so cant be optimised in this way, the positon of the rotate point matters!
