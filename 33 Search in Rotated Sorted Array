class Solution {
public:
    int search(vector<int>& nums, int target) {
        return help(nums, target, 0, nums.size()-1);
    }
    int help(vector<int>& nums, int target, int l, int r) {
        if(l>r) return -1;
        int mid = (l+r)/2;
        if(nums[mid] == target) return mid;
        if(nums[mid] > nums[r]) {   //rotate point is at the right side
            if(nums[l] <= target && target < nums[mid]) return help(nums, target, l, mid-1);
            else return help(nums, target, mid+1, r);  
        } 
        else {
            if(nums[mid] < target && target <= nums[r]) return help(nums, target, mid+1, r);
            else return help(nums, target, l, mid-1);
        }
    }
};


//the correct answer is as above, after I looked at it, I optimised it by combing some scenarios as below:
class Solution {
public:
    int search(vector<int>& nums, int target) {
        return help(nums, target, 0, nums.size()-1);
    }
    int help(vector<int>& nums, int target, int l, int r) {
        if(l>r) return -1;
        int mid = (l+r)/2;
        if(nums[mid] == target) return mid;
        //if(nums[mid] > nums[r]) {   //rotate point is at the right side
            if(nums[l] <= target && target < nums[mid]) return help(nums, target, l, mid-1);
            else return help(nums, target, mid+1, r);  
        //} 
        //else {
        //    if(nums[mid] < target && target <= nums[r]) return help(nums, target, mid+1, r);
        //    else return help(nums, target, l, mid-1);
        //}
    }
};
//it's accepted in leetcode, but submission failed, i thought it doesnt matter where the rotate point is, until failed in this case [5, 1, 3]
//the process of this test case with the correct solution is as below:
//help(nums, 5, 0, 2)
//mid = 1
//help(nums, 5, 0, 0)
//mid = 0
//return nums[0]
//if not clear enough, think of this tecase case [5,1,2,3,4]
//first scenario is if(nums[mid] > nums[r] && nums[l] <= target && target < nums[mid]) return help(nums, target, l, mid-1);
//it is return the sourted part
//'else' condition doesnt mean target is in (mid, target, r), it actually means target < l || target > nums[mid] which is not sorted area
//so the whole process is finding the sorted area and return that area, other than this scenario it's either target is in the narrowed down sorted area
//or not exists, every recursive process is to find the sorted area.
          

//the process of this test case with the optimised wrong solution is as below:
//help(nums, 5, 2, 2)    
//mid = 2
//help(nums, 5, 3, 2)
//L>r return -1
//this method skipped this scenario if(nums[l] <= target && target < nums[mid]) which is not a sorted area 
//and got into 'else' help(nums, target, mid+1, r) which is a sorted area
//so the next recursive processes will be all searching in this area which definitely cant find target
//that's why this problem cant be optimised in this way, the positon of the rotate point actually matters!

