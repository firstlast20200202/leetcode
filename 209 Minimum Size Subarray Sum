//sliding window method: 
//the variable in 'for' loop must represent the ending index rather than starting index, because if it's starting index of the sub array, in every loop
//it will go through pretty much the whole array till the end, which make the complexity O(n^2).
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT32_MAX;    //initialize to INT32_MAX, so later we can get the minimum value of res = min(res, subLength);
        int subLength = 0;
        int sum = 0; 
        int i = 0;
        for(int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            while(sum >= target) {
                subLength = j-i+1;
                res = res < subLength ? res : subLength;
                sum -= nums[i++];
            }
        }
        return res == INT32_MAX ? 0 : res;
    }
};


//brutal force method: when run this code in leetcode, it can be accepted by some test cases; but submit would cause time limit exceed issue.
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT32_MAX;
        int sum = 0;
        int subLength = 0;
        for(int i = 0; i < nums.size(); i++) {
            sum = 0;
            for(int j = i; j < nums.size(); j++) {
                sum += nums[j];
                if(sum >= target) {
                    subLength = j - i + 1;
                    res = res < subLength ? res : subLength;
                    break;
                }
            }
        }
        return res == INT_MAX ? 0 : res;
    }
};
